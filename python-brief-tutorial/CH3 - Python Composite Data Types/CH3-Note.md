
- [CH3 组合数据类型](#ch3-组合数据类型)
  - [列表](#列表)
    - [列表的定义](#列表的定义)
    - [列表的性质](#列表的性质)
    - [列表的切片](#列表的切片)
    - [列表的操作符](#列表的操作符)
    - [列表的操作方法](#列表的操作方法)
      - [增加元素](#增加元素)
      - [删除元素](#删除元素)
      - [查找元素](#查找元素)
      - [修改元素](#修改元素)
      - [列表的复制](#列表的复制)
      - [列表的排序](#列表的排序)
      - [列表的翻转](#列表的翻转)
      - [列表的遍历](#列表的遍历)
  - [元组](#元组)
    - [元组的表达](#元组的表达)
    - [元组的常见用处](#元组的常见用处)
  - [字典](#字典)
    - [字典的表达](#字典的表达)
    - [字典的性质](#字典的性质)
    - [字典的操作方法](#字典的操作方法)
  - [集合](#集合)
    - [集合的表达](#集合的表达)
    - [集合的运算](#集合的运算)
    - [集合的操作方法](#集合的操作方法)


# CH3 组合数据类型

![](https://raw.githubusercontent.com/timerring/picgo/master/picbed/image-20220911195845710.png)

## 列表

![](https://raw.githubusercontent.com/timerring/picgo/master/picbed/image-20220911195915286.png)

### 列表的定义

* 序列类型：内部元素有位置关系，能通过位置序号访问其中元素
* 列表是一个可以使用多种类型元素，支持元素的增、删、查、改操作的序列类型

```python
ls = ["Python", 1989, True, {"version": 3.7}]
```

* 另一种产生方式：list(可迭代对象)，可迭代对象包括：字符串、元组、集合、range()等

```python
list("欢迎订阅本专栏")
# ['欢', '迎', '订', '阅', '本', '专', '栏']
list(("我", "们", "很", "像"))
# ['我', '们', '很', '像']
list({"李雷", "韩梅梅", "Jim", "Green"})
# ['Green', 'Jim', '李雷', '韩梅梅']
```

`range(起始数字,中止数字,数字间隔)`

* 如果起始数字缺省，默认为0
* 必须包含中止数字，前闭后开
* 数字间隔缺省，默认为1

```python
for i in range(1, 11, 2):
    print(i)
# 1
# 3
# 5
# 7
# 9
list(range(1, 11, 2))
# [1, 3, 5, 7, 9]
```

### 列表的性质

* 列表的长度——len(列表)
* 列表的索引——**与字符串完全相同**

```python
cars = ["BYD", "BMW", "AUDI", "TOYOTA"]
print(cars[0])
# BYD
```

### 列表的切片

**变量名[开始位置：结束位置：切片间隔]**

```python
cars = ["BYD", "BMW", "AUDI", "TOYOTA"]
print(cars[:3])     # 前三个元素，开始位置缺省，默认为0；切片间隔缺省，默认为1
# ['BYD', 'BMW', 'AUDI']
print(cars[1:4:2])  # 第二个到第四个元素 前后索引差为2
# ['BMW', 'TOYOTA']
print(cars[:])      # 获取整个列表，结束位置缺省，默认取值到最后
# ['BYD', 'BMW', 'AUDI', 'TOYOTA']
print(cars[-4:-2])  # 获取前两个元素
# ['BYD', 'BMW']
```

* 反向切片


```python
cars = ["BYD", "BMW", "AUDI", "TOYOTA"]
print(cars[:-4:-1])      # 开始位置缺省，默认为-1
# ['TOYOTA', 'AUDI', 'BMW']
print(cars[::-1])        # 获得反向列表
# ['TOYOTA', 'AUDI', 'BMW', 'BYD']
```

### 列表的操作符

* 用 `+` 实现列表的拼接
* 用 `*` 实现列表的成倍复制
```python
[0]*10 # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

### 列表的操作方法

#### 增加元素

* 在末尾增加元素——列表.append(待增元素)
* 在任意位置插入元素——列表.insert(位置编号，待增元素)，在位置编号相应元素**前**插入待增元素
* 在末尾整体并入另一列表——列表1.extend(列表2)

append 将列表2整体作为一个元素添加到列表1中

```python
languages.append(["Ruby", "PHP"])
# ['Python', 'C', 'C++', 'R', 'Java', ['Ruby', 'PHP']]
```

extend 将待列表2内的元素逐个添加到列表1中，当然也可以采用加法实现。

```python
languages = ['Python', 'C', 'C++', 'R', 'Java']
languages.extend(["Ruby", "PHP"])
# ['Python', 'C', 'C++', 'R', 'Java', 'Ruby', 'PHP']
```

#### 删除元素

* 删除列表i位置的元素 `list.pop(i)`

```python
languages = ['Python', 'C', 'C++', 'R', 'Java']
languages.pop(1)
# ['Python', 'C++', 'R', 'Java']
```

* 不写位置信息，默认删除最后一个元素 `list.pop()`
* 删除列表中的第一次出现的待删元素 `list.remove(待删元素)`

#### 查找元素

* 列表中第一次出现待查元素的位置 `list.index(待查元素)` 返回索引

#### 修改元素

* 通过"先索引后赋值"的方式，对元素进行修改 `list[位置]=新值`

#### 列表的复制

* `languages_2 = languages` 错误的方式：这种方式仅是相当于给列表起了一个别名
* 正确的方式——浅拷贝

* 方法1：`列表.copy()`
* 方法2：列表 `[:]` 相当于对整个列表的切片

#### 列表的排序

* 使用 `list.sort()` 对列表进行原地排序，无返回值，默认递增。递减排列 `list.sort(reverse = True)`
* 使用 `sorted(列表)` 对列表进行临时排序，原列表保持不变，返回排序后的列表。同样递减排列 `sorted(list, reverse = True)`

#### 列表的翻转

* 使用 `list.reverse()` 对列表进行原地翻转，无返回值

#### 列表的遍历

* 使用 `for` 循环

## 元组

![](https://raw.githubusercontent.com/timerring/picgo/master/picbed/image-20220911195923824.png)

### 元组的表达

* 将元组视作“不可变的列表”
* 不支持元素增加、元素删除、元素修改操作，其他操作与列表的操作完全一致

### 元组的常见用处

**打包与解包**

* 例1 返回值是打包成元组的形式

```python
def f1(x):
    return x**2, x**3 # 打包返回

print(f1(3))
# (9, 27)
print(type(f1(3)))
# <class 'tuple'>
```

```python
a, b = f1(3) # 解包赋值 
print(a) # 9
print(b) # 27
```

* 例2 采用 `zip` 函数进行打包

```python
numbers = [201901, 201902, 201903]
name = ["小明", "小红", "小强"]
list(zip(numbers,name))
# [(201901, '小明'), (201902, '小红'), (201903, '小强')]

# 每次取到一个元组，立刻进行解包赋值
for number,name in zip(numbers,name):
    print(number, name)
# 201901 小明
# 201902 小红
# 201903 小强
```

## 字典

![](https://raw.githubusercontent.com/timerring/picgo/master/picbed/image-20220911195933975.png)

### 字典的表达

* 常规的字典是无序的，仅可以通过键来对数据进行访问

**字典键的要求**

字典的键不能重复，如果重复，前面的键就被覆盖了。

**字典的键必须是不可变类型**，如果键可变，就找不到对应存储的值了

* 不可变类型：数字、字符串、元组。
* 可变类型：列表、字典、集合。 一旦确定，还可以随意增删改。因此这三个类型不能作为字典的键。

### 字典的性质

* 字典的长度`len()`——键值对的个数
* 字典的索引，通过`字典[键]`的形式来获取对应的值

### 字典的操作方法

增加键值对

* 变量名[新键] = 新值

删除键值对

* 通过`del 变量名[待删除键]`
* 通过`变量名.pop(待删除键)`
* `变量名.popitem()` 随机删除一个键值对，并以元组返回删除键值对

修改值
* 通过先索引后赋值的方式对相应的值进行修改

`d.get( )`

* `d.get(key, default)` 从字典d中获取键key对应的值，如果没有这个键，则返回default

* 小例子：统计"牛奶奶找刘奶奶买牛奶"中字符的出现频率


```python
s = "牛奶奶找刘奶奶买牛奶"
d = {}
print(d)
for i in s:
    d[i] = d.get(i, 0)+1 # 如果该字符第一次出现，则返回default 0 ，然后+1统计。如果之前就有i这个键，则返回该 key i 所对应的值。
    print(d)
# {}
# {'牛': 1}
# {'牛': 1, '奶': 1}
# {'牛': 1, '奶': 2}
# {'牛': 1, '奶': 2, '找': 1}
# {'牛': 1, '奶': 2, '找': 1, '刘': 1}
# {'牛': 1, '奶': 3, '找': 1, '刘': 1}
# {'牛': 1, '奶': 4, '找': 1, '刘': 1}
# {'牛': 1, '奶': 4, '找': 1, '刘': 1, '买': 1}
# {'牛': 2, '奶': 4, '找': 1, '刘': 1, '买': 1}
# {'牛': 2, '奶': 5, '找': 1, '刘': 1, '买': 1}
```


`d.keys( )` `d.values( )`

把所有的key，value 单独拿出来。


```python
students = {201901: '小明', 201902: '小红', 201903: '小强'}
print(list(students.keys()))
print(list(students.values()))
# [201901, 201902, 201903]
# ['小明', '小红', '小强']
```

`d.items( )`

```python
print(list(students.items()))
# [(201901, '小明'), (201902, '小红'), (201903, '小强')]
for k, v in students.items():#进行解包
    print(k, v)
# 201901 小明
# 201902 小红
# 201903 小强
```

## 集合

![](https://raw.githubusercontent.com/timerring/picgo/master/picbed/image-20220911195943655.png)

### 集合的表达

* 一系列互不相等元素的**无序**集合（互斥），可以用于去重
* **元素必须是不可变类型**：数字，字符串或元组，可视作字典的键
* 可以看做是没有值，或者值为None的字典

### 集合的运算

* `S & T` 返回一个新集合，包括同时在集合S和T中的元素
* `S | T` 返回一个新集合，包括集合S和T中的所有元素
* `S ^ T` 返回一个新集合，**包括集合S和T中的非共同元素**
* `S - T` 返回一个新集合，包括在集合S但不在集合T中的元素

### 集合的操作方法

* 增加元素 `S.add(x)`
* 移除元素 `S.remove(x)`
* 集合的长度——`len(S)`
* 集合的遍历——借助for循环

```python
for star in stars:
    print(star)
```

[返回首页](https://github.com/timerring/dive-into-AI)
